/* Cyclical figurate numbers
 * Problem 061
 *
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
 * numbers are all figurate (polygonal) numbers and are generated by the
 * following formulae:
 *
 *    Triangle   P3,n = n(n+1)/2    1, 3, 6, 10, 15, ...
 *    Square     P4,n = n^2         1, 4, 9, 16, 25, ...
 *    Pentagonal P5,n = n(3n-1)/2   1, 5, 12, 22, 35, ...
 *    Hexagonal  P6,n = n(2n-1)     1, 6, 15, 28, 45, ...
 *    Heptagonal P7,n = n(5n-3)/2   1, 7, 18, 34, 55, ...
 *    Octagonal  P8,n = n(3n-2)     1, 8, 21, 40, 65, ...
 *
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
 * interesting properties.
 *
 *    1. The set is cyclic, in that the last two digits of each number are
 *       the first two digits of the next number (including the last number
 *       with the first).
 *    2. Each polygonal type: triangle (P3,127 = 8128),
 *       square (P4,91 = 8281), and pentagonal (P5,44 = 2882), is
 *       represented by a different number in the set.
 *    3. This is the only set of 4-digit numbers with this property.
 *
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for
 * which each polygonal type: triangle, square, pentagonal, hexagonal,
 * heptagonal, and octagonal, is represented by a different number in the
 * set.
 */

#include <stdio.h>

// Data ranges calculated by hand
#define TRI_MIN_N 45
#define TRI_MAX_N 140
#define TRI_VALID 96
#define SQU_MIN_N 32
#define SQU_MAX_N 99
#define SQU_VALID 68
#define PEN_MIN_N 26
#define PEN_MAX_N 81
#define PEN_VALID 56
#define HEX_MIN_N 23
#define HEX_MAX_N 70
#define HEX_VALID 48
#define HEP_MIN_N 21
#define HEP_MAX_N 63
#define HEP_VALID 43
#define OCT_MIN_N 19
#define OCT_MAX_N 58
#define OCT_VALID 40

#define N 6

void cycles(int cycle[], int fig[], int used) {
  int n, p = 0;
  if (used == N && cycle[N-1] % 100 == cycle[0] / 100) {
    printf("Six cyclical 4-digit numbers: ");
    for (n = 0; n < N; ++n) {
      printf("%d ", cycle[n]);
      p += cycle[n];
    }
    printf("(sum = %d)\n", p);
    return;
  }
  if (! fig[5]) { // OCT
    fig[5] = 1;
    for (n = OCT_MIN_N; n < OCT_MAX_N; ++n) {
      p = n * (3 * n - 2);
      if (cycle[used-1] % 100 == p / 100) {
        cycle[used] = p;
        cycles(cycle, fig, used + 1);
      }
    }
    fig[5] = 0;
  }
  if (! fig[4]) { // HEP
    fig[4] = 1;
    for (n = HEP_MIN_N; n < HEP_MAX_N; ++n) {
      p = n * (5 * n - 3) / 2;
      if (cycle[used-1] % 100 == p / 100) {
        cycle[used] = p;
        cycles(cycle, fig, used + 1);
      }
    }
    fig[4] = 0;
  }
  if (! fig[3]) { // HEX
    fig[3] = 1;
    for (n = HEX_MIN_N; n < HEX_MAX_N; ++n) {
      p = n * (2 * n - 1);
      if (cycle[used-1] % 100 == p / 100) {
        cycle[used] = p;
        cycles(cycle, fig, used + 1);
      }
    }
    fig[3] = 0;
  }
  if (! fig[2]) { // PEN
    fig[2] = 1;
    for (n = PEN_MIN_N; n < PEN_MAX_N; ++n) {
      p = n * (3 * n - 1) / 2;
      if (cycle[used-1] % 100 == p / 100) {
        cycle[used] = p;
        cycles(cycle, fig, used + 1);
      }
    }
    fig[2] = 0;
  }
  if (! fig[1]) { // SQU
    fig[1] = 1;
    for (n = SQU_MIN_N; n < SQU_MAX_N; ++n) {
      p = n * n;
      if (cycle[used-1] % 100 == p / 100) {
        cycle[used] = p;
        cycles(cycle, fig, used + 1);
      }
    }
    fig[1] = 0;
  }
  if (! fig[0]) { // TRI
    fig[0] = 1;
    for (n = TRI_MIN_N; n < TRI_MAX_N; ++n) {
      p = n * (n + 1) / 2;
      if (cycle[used-1] % 100 == p / 100) {
        cycle[used] = p;
        cycles(cycle, fig, used + 1);
      }
    }
    fig[0] = 0;
  }
}

int main() {
  int cycle[N] = { 0 }, fig[N] = { 0 }, n;
  fig[N-1] = 1;
  for (n = OCT_MIN_N; n < OCT_MAX_N; ++n) {
    cycle[0] = n * (3 * n - 2);
    cycles(cycle, fig, 1);
  }

  return 0;
}
